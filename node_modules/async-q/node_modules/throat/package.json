{
  "name": "throat",
  "version": "1.0.0",
  "description": "Throttle the parallelism of an asynchronous (promise returning) function / functions",
  "keywords": [
    "promise",
    "aplus",
    "then",
    "throttle",
    "concurrency",
    "parallelism",
    "limit"
  ],
  "dependencies": {
    "promise": "~3.2.0"
  },
  "devDependencies": {
    "mocha": "*"
  },
  "scripts": {
    "test": "mocha -R spec"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/ForbesLindesay/throat.git"
  },
  "author": {
    "name": "ForbesLindesay"
  },
  "license": "MIT",
  "readme": "# throat\r\n\r\nThrottle the parallelism of an asynchronous, promise returning, function / functions.  This has special utility when you set the concurrency to `1`.  That way you get a mutually exclusive lock.\r\n\r\n[![Build Status](https://travis-ci.org/ForbesLindesay/throat.png?branch=master)](https://travis-ci.org/ForbesLindesay/throat)\r\n[![Dependency Status](https://gemnasium.com/ForbesLindesay/throat.png)](https://gemnasium.com/ForbesLindesay/throat)\r\n[![NPM version](https://badge.fury.io/js/throat.png)](http://badge.fury.io/js/throat)\r\n\r\n## Installation\r\n\r\n    npm install throat\r\n\r\n## API\r\n\r\n### throat(concurrency)\r\n\r\nThis returns a function that acts a bit like a lock (exactly as a lock if concurrency is 1).\r\n\r\nExample, only 2 of the following functions will execute at any one time:\r\n\r\n```js\r\nvar throat = require('throat')(2)\r\n\r\nvar resA = throat(function () {\r\n  //async stuff\r\n  return promise\r\n})\r\nvar resA = throat(function () {\r\n  //async stuff\r\n  return promise\r\n})\r\nvar resA = throat(function () {\r\n  //async stuff\r\n  return promise\r\n})\r\nvar resA = throat(function () {\r\n  //async stuff\r\n  return promise\r\n})\r\nvar resA = throat(function () {\r\n  //async stuff\r\n  return promise\r\n})\r\n```\r\n\r\n### throat(concurrency, worker)\r\n\r\nThis returns a function that is an exact copy of `worker` except that it will only execute up to `concurrency` times in parallel before further requests are queued:\r\n\r\n```js\r\nvar input = ['fileA.txt', 'fileB.txt', 'fileC.txt', 'fileD.txt']\r\nvar data = Promise.all(input.map(throat(2, function (fileName) {\r\n  return readFile(fileName)\r\n})))\r\n```\r\n\r\nOnly 2 files will be read at a time, sometimes limiting parallelism in this way can improve scalability.\r\n\r\n## License\r\n\r\n  MIT",
  "readmeFilename": "README.md",
  "_id": "throat@1.0.0",
  "dist": {
    "shasum": "04c9e0f9ce88e250db630fdeabc2e5bb152a0625",
    "tarball": "http://registry.npmjs.org/throat/-/throat-1.0.0.tgz"
  },
  "_from": "throat@~1.0.0",
  "_npmVersion": "1.2.10",
  "_npmUser": {
    "name": "forbeslindesay",
    "email": "forbes@lindesay.co.uk"
  },
  "maintainers": [
    {
      "name": "forbeslindesay",
      "email": "forbes@lindesay.co.uk"
    }
  ],
  "directories": {},
  "_shasum": "04c9e0f9ce88e250db630fdeabc2e5bb152a0625",
  "_resolved": "https://registry.npmjs.org/throat/-/throat-1.0.0.tgz"
}
